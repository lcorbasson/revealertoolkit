<?php

// This file contains an XML parser to extract commands,
// given certain filters.
// Also there is a class implementation for a generic command

define('NOT_EXECUTED',0);
define('WORKING',1);
define('SUCCESS',2);


class command{
	var $filled = false; //gets whether this command object has been filled (assigned)

	var $name;
	var $alias;
	var $description;
	var $objects;	//null = can apply always (no context)
	var $module;
	var $function;
	var $args;		//null = no parameters (void)
	var $pre;		//null = can apply always (no preconditions)
	var $standard;	//null = no standard output given
	var $files;		//null = no files created
	var $icon;		//null = no graphical representation (internal)
	var $advanced;
	var $expansion;
	var $multiple;
	var $viewer;	//null = no need to change current view

	// CAN_EXECUTE checks for all required preconditions to accomplish
	function can_execute (){
		if (!filled) return false;
		/*FUNCION DE DEPENDENCIAS*/
		return true;
	}
	
	// PROC_ARGS translates each codename to the actual value
	// for the argument, returning a quoted comma-separated string
	function proc_args(){
		if(count($this->args) == 0) return '';
		global $CASE,$INPUT,$OBJECT,$RESERVED;
		$retVal = "'" . implode("','",compact($this->args)) . "'";
		return $retVal;
	}
	
	// EXECUTE calls the specified function with the required arguments
	// and returns the bunch of text lines printed in the stdout, if so
	function execute (){
		if ($this->can_execute()){
			chdir(RVT_PATH);
			$perl = new Perl();
			$perl->eval("use lib '" . RVT_PATH . "';");
			$perl->eval("use $this->module;");
			$perl->eval("use XML::Simple;");
			$perl->eval("require '" . INIT_MODULE . "'");
			ob_start();
			$perl->eval("$this->function(" . $this->proc_args() . ");");
			$retVal = ob_get_contents();
			ob_end_clean();
		}
		return $retVal;
	}

	//ISEXECUTED returns a constant that specifies whether this command has
	//performed any operation over a certain object
	//Possible results are:
	//	- NOT_EXECUTED
	//	- WORKING
	//	- SUCCESS
	function isExecuted($object){
		chdir(RVT_PATH);
		$perl = new Perl();
		$perl->eval("use lib '" . RVT_PATH . "';");
		$perl->eval("use RVTbase::RVT_core;");
		$perl->eval("use XML::Simple;");
		$perl->eval("require '" . INIT_MODULE . "'");
		ob_start();
		$perl->eval(RVT_CHECK_EXECUTION . "(" . $this->proc_args() . ");");
		$retVal = ob_get_contents();
		ob_end_clean();
	}
	
}

require_once 'globals.php';

// returns an XML object that contains the command list
function load_xml(){
	if (file_exists(XMLCOMMAND_PATH)){
		if( $xml = simplexml_load_file(XMLCOMMAND_PATH) )
			return $xml;
		else
			exit('Error parsing ' . XMLCOMMAND_PATH . ' file.');
	}
	else
		exit(XMLCOMMAND_PATH . ' file not found.');
}

// returns an array with the set of applicable objects for this command
function load_objects($command){
	$retVal = array();
	foreach($command->objects->object as $object)
		$retVal[] = (string)$object;
	return $retVal;
}

// returns an array with the set of arguments for this command
function load_args($command){
	$retVal = array();
	foreach($command->args->arg as $arg)
		$retVal[] = strtoupper((string)$arg);
	return $retVal;
}

// returns a tree-formatted array with the preconditions for this command
function load_pre($command){
	$retVal = array();
}

// returns an array with the set of files generated by this command
function load_files($command){
	$retVal = array();
	foreach($command->files->file as $file)
		$retVal[] = (string)$file;
	return $retVal;
}

// maps a command, from the XML to an object
function map_command($command){
	$c = new command();
	$c->name = (string)$command->name;
	$c->alias = (string)$command->alias;
	$c->description = (string)$command->description;
	$c->objects = ((bool)$command->objects) ? load_objects($command) : null;
	$c->module = (string)$command->module;
	$c->function = (string)$command->function;
	$c->args = ((bool)$command->args) ? load_args($command) : null;
	$c->pre = NULL; //((bool)$command->pre) ? load_pre($command) : null;
	$c->standard = ((bool)$command->standard) ? $command->standard : null;
	$c->files = ((bool)$command->files) ? load_files($command) : null;
	$c->icon = ((bool)$command->icon) ? $command->icon : null;
	$c->advanced = (bool)$command->advanced;
	$c->expansion = (bool)$command->expansion;
	$c->multiple = $command->multiple;
	$c->viewer = ((bool)$command->viewer) ? $command->viewer : null;
	
	$c->filled = true;
	return $c;
}

// gets a command given its name
function command_by_name($name){
	$tmp = load_xml();
	foreach ($tmp->command as $command)
		if((string) $command->name == $name)
			return map_command($command);
	return null;
}

// gets a list of commands given the object to apply them on
function commands_by_object($object){
	$retVal = array();
	$tmp = load_xml();
	foreach ($tmp->command as $command)
		if((load_objects($command) === null) || (in_array($object, load_objects($command))))
			$retVal[] = map_command($command);
	return $retVal;
}

?>